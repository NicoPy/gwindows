
-- This header comes from RC.y (bottom)

with RC_Tokens, RC_Shift_Reduce, RC_Goto, RC_Help, RC_IO;
use  RC_Tokens, RC_Shift_Reduce, RC_Goto, RC_Help, RC_IO;

with RC_DFA, YYroutines, YYerror;
use  RC_DFA, YYroutines;

with Ada.Text_IO;                       use Ada.Text_IO;
with Text_IO; -- for compat.

with Ada.Characters.Handling;           use Ada.Characters.Handling;
with Ada.Strings.Fixed;                 use Ada.Strings, Ada.Strings.Fixed;

with Interfaces;                        use Interfaces;

with GWindows.Static_Controls;

-- Header end.

--  Warning: This file is automatically generated by AYACC.
--           It is useless to modify it. Change the ".Y" & ".L" files instead.

with YY_Sizes;
-- ^ 14-Jan-2006 (GdM): configurable sizes instead of hard-coded
--   ones in AYACC's output

procedure YYParse is

   -- Rename User Defined Packages to Internal Names.
    package yy_goto_tables         renames
      Rc_Goto;
    package yy_shift_reduce_tables renames
      Rc_Shift_Reduce;
    package yy_tokens              renames
      Rc_Tokens;
    package yy_io                  renames -- (+GdM 2008)
      Rc_IO;

   use yy_tokens, yy_goto_tables, yy_shift_reduce_tables;

   procedure yyerrok;
   procedure yyclearin;


   package yy is

       -- the size of the value and state stacks
       --  Affects error 'Stack size exceeded on state_stack'
       stack_size : constant Natural := yy_sizes.stack_size; -- was 300, then 8192

       -- subtype rule         is natural;
       subtype parse_state  is natural;
       -- subtype nonterminal  is integer;

       -- encryption constants
       default           : constant := -1;
       first_shift_entry : constant :=  0;
       accept_code       : constant := -3001;
       error_code        : constant := -3000;

       -- stack data used by the parser
       tos                : natural := 0;
       value_stack        : array(0..stack_size) of yy_tokens.yystype;
       state_stack        : array(0..stack_size) of parse_state;

       -- current input symbol and action the parser is on
       action             : integer;
       rule_id            : rule;
       input_symbol       : yy_tokens.token:= Error;


       -- error recovery flag
       error_flag : natural := 0;
          -- indicates  3 - (number of valid shifts after an error occurs)

       look_ahead : boolean := true;
       index      : integer;

       -- Is Debugging option on or off
        DEBUG : constant boolean := FALSE;

    end yy;


    function goto_state
      (state : yy.parse_state;
       sym   : nonterminal) return yy.parse_state;

    function parse_action
      (state : yy.parse_state;
       t     : yy_tokens.token) return integer;

    pragma inline(goto_state, parse_action);


    function goto_state(state : yy.parse_state;
                        sym   : nonterminal) return yy.parse_state is
        index : integer;
    begin
        index := goto_offset(state);
        while  integer(goto_matrix(index).nonterm) /= sym loop
            index := index + 1;
        end loop;
        return integer(goto_matrix(index).newstate);
    end goto_state;


    function parse_action(state : yy.parse_state;
                          t     : yy_tokens.token) return integer is
        index      : integer;
        tok_pos    : integer;
        default    : constant integer := -1;
    begin
        tok_pos := yy_tokens.token'pos(t);
        index   := shift_reduce_offset(state);
        while integer(shift_reduce_matrix(index).t) /= tok_pos and then
              integer(shift_reduce_matrix(index).t) /= default
        loop
            index := index + 1;
        end loop;
        return integer(shift_reduce_matrix(index).act);
    end parse_action;

-- error recovery stuff

    procedure handle_error is
      temp_action : integer;
    begin

      if yy.error_flag = 3 then -- no shift yet, clobber input.
      if yy.debug then
          text_io.put_line("Ayacc.YYParse: Error Recovery Clobbers " &
                   yy_tokens.token'image(yy.input_symbol));
      end if;
        if yy.input_symbol = yy_tokens.end_of_input then  -- don't discard,
        if yy.debug then
            text_io.put_line("Ayacc.YYParse: Can't discard END_OF_INPUT, quiting...");
        end if;
        raise yy_tokens.syntax_error;
        end if;

            yy.look_ahead := true;   -- get next token
        return;                  -- and try again...
    end if;

    if yy.error_flag = 0 then -- brand new error
        if yy_io.Input_Line > 1 then
            yyerror("Syntax Error at line" & Text_IO.Count'Image(yy_io.Input_Line));
        else
            yyerror("Syntax Error at line 1 (or possibly later and the AFLex -E option was omitted).");
        end if;
    end if;

    yy.error_flag := 3;

    -- find state on stack where error is a valid shift --

    if yy.debug then
        text_io.put_line("Ayacc.YYParse: Looking for state with error as valid shift");
    end if;

    loop
        if yy.debug then
          text_io.put_line("Ayacc.YYParse: Examining State " &
               yy.parse_state'image(yy.state_stack(yy.tos)));
        end if;
        temp_action := parse_action(yy.state_stack(yy.tos), error);

            if temp_action >= yy.first_shift_entry then
                if yy.tos = yy.stack_size then
                    text_io.put_line(" Stack size exceeded on state_stack");
                    raise yy_Tokens.syntax_error;
                end if;
                yy.tos := yy.tos + 1;
                yy.state_stack(yy.tos) := temp_action;
                exit;
            end if;

        Decrement_Stack_Pointer :
        begin
          yy.tos := yy.tos - 1;
        exception
          when Constraint_Error =>
            yy.tos := 0;
        end Decrement_Stack_Pointer;

        if yy.tos = 0 then
          if yy.debug then
            text_io.put_line("Ayacc.YYParse: Error recovery popped entire stack, aborting...");
          end if;
          raise yy_tokens.syntax_error;
        end if;
    end loop;

    if yy.debug then
        text_io.put_line("Ayacc.YYParse: Shifted error token in state " &
              yy.parse_state'image(yy.state_stack(yy.tos)));
    end if;

    end handle_error;

   -- print debugging information for a shift operation
   procedure shift_debug(state_id: yy.parse_state; lexeme: yy_tokens.token) is
   begin
       text_io.put_line("Ayacc.YYParse: Shift "& yy.parse_state'image(state_id)&" on input symbol "&
               yy_tokens.token'image(lexeme) );
   end;

   -- print debugging information for a reduce operation
   procedure reduce_debug(rule_id: rule; state_id: yy.parse_state) is
   begin
       text_io.put_line("Ayacc.YYParse: Reduce by rule "&rule'image(rule_id)&" goto state "&
               yy.parse_state'image(state_id));
   end;

   -- make the parser believe that 3 valid shifts have occured.
   -- used for error recovery.
   procedure yyerrok is
   begin
       yy.error_flag := 0;
   end yyerrok;

   -- called to clear input symbol that caused an error.
   procedure yyclearin is
   begin
       -- yy.input_symbol := yylex;
       yy.look_ahead := true;
   end yyclearin;


begin
    -- initialize by pushing state 0 and getting the first input symbol
    yy.state_stack(yy.tos) := 0;


    loop

        yy.index := shift_reduce_offset(yy.state_stack(yy.tos));
        if integer(shift_reduce_matrix(yy.index).t) = yy.default then
            yy.action := integer(shift_reduce_matrix(yy.index).act);
        else
            if yy.look_ahead then
                yy.look_ahead   := false;

                yy.input_symbol := yylex;
            end if;
            yy.action :=
             parse_action(yy.state_stack(yy.tos), yy.input_symbol);
        end if;


        if yy.action >= yy.first_shift_entry then  -- SHIFT

            if yy.debug then
                shift_debug(yy.action, yy.input_symbol);
            end if;

            -- Enter new state
            if yy.tos = yy.stack_size then
                text_io.put_line(" Stack size exceeded on state_stack");
                raise yy_Tokens.syntax_error;
            end if;
            yy.tos := yy.tos + 1;
            yy.state_stack(yy.tos) := yy.action;
              yy.value_stack(yy.tos) := yylval;

        if yy.error_flag > 0 then  -- indicate a valid shift
            yy.error_flag := yy.error_flag - 1;
        end if;

            -- Advance lookahead
            yy.look_ahead := true;

        elsif yy.action = yy.error_code then       -- ERROR

            handle_error;

        elsif yy.action = yy.accept_code then
            if yy.debug then
                text_io.put_line("Ayacc.YYParse: Accepting Grammar...");
            end if;
            exit;

        else -- Reduce Action

            -- Convert action into a rule
            yy.rule_id  := -1 * yy.action;

            -- Execute User Action
            -- user_action(yy.rule_id);


                case yy.rule_id is

when 1 => -- #line 205
RC_Help.YY_ACCEPT;

when 2 => -- #line 206
RC_Help.YY_ABORT;

when 43 => -- #line 271
 if anonymous_item then
                   anonymous_dialog_counter:=
                     anonymous_dialog_counter+1;
                   last_dialog_ident:= U("Dialog_" &
                     Trim(Integer'Image(anonymous_dialog_counter),both));
                 else
                   last_dialog_ident:= last_ident;
                 end if;
               

when 44 => -- #line 281

                 Open_if_separate(S(last_dialog_ident));
                 Ada_Put_Line(to_spec,
                   "  type " & S(last_dialog_ident) &
                   "_Type is new Window_type with record"
                 );
                 Ada_New_Line(to_spec);
                 Ada_New_Line(to_body);
                 last_caption:= U("""""");
                 style_switch:= (others => False); -- Reset all style switches
                 static_counter:= 0;
               

when 45 => -- #line 295

                 last_dialog_rect:= last_rect;
               

when 46 => -- #line 299

                 last_dialog_caption:= last_caption;
                 Ada_Proc_Dialog(
                    to_body,
                    S(last_dialog_ident) & "_Type",
                    S(last_dialog_caption)
                 );
               

when 47 => -- #line 309
 empty_dialog_record:= True; 

when 48 => -- #line 312
 Ada_Proc_Dialog(
                    to_spec,
                    S(last_dialog_ident) & "_Type",
                    S(last_dialog_caption)
                 );
                 Ada_Put_Line(to_spec, ";");
                 Ada_New_Line(to_spec);
                 Ada_Put_Line(to_body,
                   "  end Create_Contents; -- " &
                   S(last_dialog_ident) & "_Type" );
                 Ada_New_Line(to_body);
                 Close_if_separate(S(last_dialog_ident));
               

when 78 => -- #line 390
 style_switch(shell_font):= True; 

when 79 => -- #line 391
 style_switch(shell_font):= True; 

when 80 => -- #line 392
 style_switch(shell_font):= True; 

when 92 => -- #line 420
 last_caption:= U(yytext); 

when 94 => -- #line 424

              style_switch:= (others => False); -- Reset all style switches
              last_text:= U("""""");
            

when 97 => -- #line 433
empty_dialog_record:= False;

when 99 => -- #line 435
empty_dialog_record:= False;

when 100 => -- #line 436
empty_dialog_record:= False;

when 101 => -- #line 437
empty_dialog_record:= False;

when 102 => -- #line 438
empty_dialog_record:= False;

when 103 => -- #line 439
empty_dialog_record:= False;

when 104 => -- #line 440
empty_dialog_record:= False;

when 105 => -- #line 441
empty_dialog_record:= False;

when 106 => -- #line 442
empty_dialog_record:= False;

when 107 => -- #line 452
 control:= unknown; 

when 108 => -- #line 454
 last_control_text:= U(yytext); 

when 109 => -- #line 457
 Insert_last_symbol;
               

when 110 => -- #line 461
 last_class:= U(yytext); 

when 111 => -- #line 467
  if control /= unknown then
                    empty_dialog_record:= False;
                  end if;
                  case control is
                    when unknown =>
                      Ada_Comment(to_spec, "Unknown Class = " & S(last_class));
                    when bitmap =>
                      Ada_normal_control(
                        "Bitmap_Type",
                         ", Num_resource(" & S(last_control_text) & ')',
                         -- ^ direct resource name, as string
                         "",
                        with_id => False
                      );
                    when track_bar =>
                      Ada_normal_control(
                        "Trackbar_Control_Type",
                         "",
                         ", " & Trackbar_Control_Ticks_Type'Image(Trackbar_Control_Ticks) &
                         ", " & Control_Direction_Type'Image(Control_Direction) &
                         ", Tips => " & Boolean'Image(style_switch(tips)),
                         with_id => False
                      );
                    when up_down =>
                      Ada_normal_control(
                        "Up_Down_Control_Type",
                         "",
                         ", " & Boolean'Image(style_switch(keys)) &
                         ", " & Control_Direction_Type'Image(Control_Direction) &
                         ", " & Boolean'Image(style_switch(wrap)) &
						 ", Auto_Buddy => False" &
                         ", Thousands => " & Boolean'Image(not style_switch(no_1000)),
                         with_id => False
                      );
                    when progress =>
                      Ada_normal_control("Progress_Control_Type", with_id => False );
                    when list_view =>
                      Ada_normal_control("List_View_Control_Type", with_id => False );
                    when tree_view =>
                      Ada_normal_control("List_View_Control_Type", with_id => False );
                    when tab_control =>
                      Ada_normal_control("Tab_Window_Control_Type", with_id => False );
                      -- Tab_Window_Control_Type allows to associate a window
                      -- to a tab via the Tab_Window method
                    when date_time =>
                      Ada_normal_control(
                        "Date_Time_Picker_Type",
                         "",
                         ", Method=> Up_Down",
                        with_id => False
                      );
                    when calendar =>
                      Ada_normal_control(
                        "Date_Time_Picker_Type",
                         "",
                         ", Method => Calendar",
                        with_id => False
                      );
                  end case;
               

when 118 => -- #line 552
 control:= date_time;
		

when 121 => -- #line 558
 control:= calendar;
		

when 123 => -- #line 563
 control:= progress;
          Control_Direction:= Horizontal;
		

when 129 => -- #line 573
 control:= track_bar;
          Trackbar_Control_Ticks:= No_Ticks;
          Control_Direction:= Horizontal;
        

when 130 => -- #line 578
 control:= up_down;
          Control_Direction:= Vertical;
		

when 139 => -- #line 591
 control:= list_view;
		

when 144 => -- #line 601
 control:= tab_control;
		

when 145 => -- #line 605
 control:= tree_view;
		

when 152 => -- #line 619
 Control_Direction:= Vertical; 

when 153 => -- #line 621
 Control_Direction:= Vertical; 

when 154 => -- #line 623
 Trackbar_Control_Ticks:= Top_Ticks; 

when 155 => -- #line 625
 Trackbar_Control_Ticks:= Bottom_Ticks; 

when 158 => -- #line 630
 style_switch(tips):= True; 

when 160 => -- #line 633
 Control_Direction:= Horizontal; 

when 161 => -- #line 635
 style_switch(keys):= True; 

when 162 => -- #line 637
 style_switch(wrap):= True; 

when 163 => -- #line 639
 style_switch(no_1000):= True; 

when 171 => -- #line 648
 style_switch(tips):= True; 

when 202 => -- #line 697
 control:= bitmap; 

when 213 => -- #line 720

              if style_switch(multi_line) then
                Ada_normal_control(
                  "Multi_Line_Edit_Box_Type",
                  ", " & S(last_text),
                  ", " & Boolean'Image(style_switch(auto_h_scroll))
                );
              else
                Ada_normal_control(
                  "Edit_Box_Type",
                  ", " & S(last_text),
                  ", " & Boolean'Image(style_switch(auto_h_scroll))
                );
              end if;
            

when 224 => -- #line 759
 style_switch(multi_line):= True; 

when 226 => -- #line 761
 style_switch(auto_h_scroll):= True; 

when 227 => -- #line 762
 style_switch(auto_v_scroll):= True; 

when 235 => -- #line 777

              if anonymous_item then
                Ada_Coord_conv(last_rect);
                Ada_Put_Line(to_spec, "    -- Label: " & S(last_ident) );
                Ada_Put_Line(to_body,
                  "    Create_label( Window, " &
                  S(last_text) &
                  ", x,y,w,h, GWindows.Static_Controls." &
                  GWindows.Static_Controls.Alignment_Type'Image(last_alignment)
                  & ");"
                );
              else
                empty_dialog_record:= False;
                Ada_normal_control(
                  "Label_Type",
                  ", " & S(last_text),
                  ", GWindows.Static_Controls." &
                  GWindows.Static_Controls.Alignment_Type'Image(last_alignment)
                );
              end if;
            

when 236 => -- #line 800
last_alignment:= GWindows.Static_Controls.Left;   

when 237 => -- #line 801
last_alignment:= GWindows.Static_Controls.Center; 

when 238 => -- #line 802
last_alignment:= GWindows.Static_Controls.Right;  

when 239 => -- #line 810
 combo:= no_drop; 

when 240 => -- #line 814

              Ada_normal_control(
                Combo_type_name(combo),
                 ", " & S(last_text),
                 ", " & Boolean'Image(style_switch(sort))
              );
            

when 245 => -- #line 833
 combo:= no_drop; 

when 246 => -- #line 834
 combo:= drop_down; 

when 247 => -- #line 835
 combo:= drop_down_list; 

when 248 => -- #line 836
 style_switch(sort):= True; 

when 255 => -- #line 852

              Ada_Put_Line(to_spec, "    " & S(last_Ada_ident) & ": Group_Box_Type;");
              Ada_Coord_conv(last_rect);
              Ada_Put_Line(to_body,
                "    Create( Window." & S(last_Ada_ident) & ", Window, " &
                S(last_text) & ", x,y,w,h);"
              );
            

when 263 => -- #line 886

              Ada_normal_control(
                "List_Box_Type",
                 "",
                 ", " & Boolean'Image(style_switch(sort))
              );
            

when 270 => -- #line 910
 style_switch(sort):= True; 

when 284 => -- #line 933
 if style_switch(state3) then
                Ada_normal_control("Three_State_Box_Type", ", " & S(last_text));
              else
                Ada_normal_control("Check_Box_Type", ", " & S(last_text));
              end if;
            

when 285 => -- #line 942
 style_switch(auto):= False;
                 style_switch(state3):= False;
               

when 286 => -- #line 946
 style_switch(auto):= False;
                 style_switch(state3):= True;
               

when 287 => -- #line 950
 style_switch(auto):= True;
                 style_switch(state3):= False;
               

when 288 => -- #line 954
 style_switch(auto):= True;
                 style_switch(state3):= True;
               

when 297 => -- #line 978
 style_switch(auto):= True; 

when 298 => -- #line 980
 style_switch(state3):= True; 

when 299 => -- #line 982
 style_switch(auto):= True; 

when 314 => -- #line 1007

              Ada_Coord_conv(last_rect);
              -- Here it is a bit tricky, since, as expected,
              -- Dialog_Button's close the window and Button don't .
              -- If we want a "real", permanent, window, then we want
              -- the latter sort.
              --
              -- "Dialog" version of the button
              --
              Ada_Put(to_spec, "    " & S(last_Ada_ident) & ": ");
              if style_switch(default) then
                Ada_Put(to_spec, "Default_");
              end if;
              Ada_Put_Line(to_spec, "Dialog_Button_Type;    -- closes parent window after click" );
              Ada_Put_Line(to_body, "    -- Both versions of the button are created.");
              Ada_Put_Line(to_body, "    -- The more meaningful one is made visible, but this choice");
              Ada_Put_Line(to_body, "    -- can be reversed, for instance on a ""Browse"" button.");
              Ada_normal_control_create(", " & S(last_text));
              --
              -- "Window" version of the button
              --
              temp_ustr:= last_Ada_ident;
              last_Ada_ident:= U(S(last_Ada_ident) & "_permanent");
              Ada_Put(to_spec, "    " & S(last_Ada_ident) & ": ");
              if style_switch(default) then
                Ada_Put(to_spec, "Default_");
              end if;
              Ada_Put_Line(to_spec, "Button_Type; -- doesn't close parent window after click" );
              Ada_normal_control_create(", " & S(last_text));
              Ada_Put_Line(to_body, "    if for_dialog then -- hide the non-closing button");
              Ada_Put_Line(to_body, "      Window." & S(last_Ada_ident) & ".Hide;");
              Ada_Put_Line(to_body, "    else -- hide the closing button");
              Ada_Put_Line(to_body, "      Window." & S(temp_ustr) & ".Hide;");
              Ada_Put_Line(to_body, "    end if;");
            

when 316 => -- #line 1047
 style_switch(default):= True; 

when 317 => -- #line 1058

              Ada_normal_control(
                "Radio_Button_Type",
                ", " & S(last_text));
            

when 320 => -- #line 1078

              if style_switch(vertical) then
                Ada_normal_control("GWindows.Scroll_Bars.Scroll_Bar_Type", ", Vertical");
              else
                Ada_normal_control("GWindows.Scroll_Bars.Scroll_Bar_Type", ", Horizontal");
              end if;
            

when 325 => -- #line 1097
 style_switch(vertical):= True; 

when 328 => -- #line 1108
 last_control_text:= U(yytext); 

when 329 => -- #line 1112

              Ada_normal_control(
                "GWindows.Static_Controls.Icon_Type",
                ", Num_resource(" & S(last_control_text) & ')' ,
                with_id => False);
            

when 332 => -- #line 1128
 Insert_last_symbol; 

when 334 => -- #line 1135
 last_text:= U(yytext); 

when 336 => -- #line 1141
 RC_Help.last_rect.x:= yylval.intval;
       

when 337 => -- #line 1145
 RC_Help.last_rect.y:= yylval.intval;
       

when 338 => -- #line 1149
 RC_Help.last_rect.w:= yylval.intval;
       

when 339 => -- #line 1153
 RC_Help.last_rect.h:= yylval.intval;
       

when 340 => -- #line 1162
 if anonymous_item then
           anonymous_menu_counter:=
             anonymous_menu_counter+1;
           last_dialog_ident:= U("Menu_" &
             Trim(Integer'Image(anonymous_menu_counter),both));
         else
           last_dialog_ident:= last_ident;
         end if;
       

when 341 => -- #line 1173

         Open_if_separate(S(last_dialog_ident));
         Ada_Put_Line(to_spec,
           "  type " & S(last_dialog_ident) &
           "_Type is tagged record"
         );
         menu_popup_counter:= 0;
         popup_top:= 0;
         Ada_Put_Line(to_spec,
           "    Main: Menu_Type; -- Root of the whole menu tree"
         );
         Ada_New_Line(to_body);
         Ada_Proc_Menu(
            to_body,
            S(last_dialog_ident) & "_Type"
         );
         Ada_New_Line(to_body);
         Ada_Put_Line(to_body, "  is");
         Ada_Put_Line(to_body, "  begin");
         Ada_Put_Line(to_body, "    Menu.Main:= Create_Menu;");
       

when 342 => -- #line 1195
 empty_dialog_record:= True;
       

when 343 => -- #line 1199
 if empty_dialog_record then
           Ada_Put_Line(to_spec, "    null; -- empty!");
         end if;
         Ada_Put_Line(to_spec,
           "  end record; -- " & S(last_dialog_ident) & "_Type"
         );
         Ada_New_Line(to_spec);
         Ada_Proc_Menu(
            to_spec,
            S(last_dialog_ident) & "_Type"
         );
         Ada_Put_Line(to_spec, ";");
         Ada_New_Line(to_spec);
         Ada_Put_Line(to_body,
           "  end Create_Full_Menu; -- " &
           S(last_dialog_ident) & "_Type" );
         Ada_New_Line(to_body);
         Close_if_separate(S(last_dialog_ident));
       

when 350 => -- #line 1234
 empty_dialog_record:= False; 

when 351 => -- #line 1239
 last_popup_title:= U(yytext); 

when 352 => -- #line 1241

              menu_popup_counter:= menu_popup_counter + 1;
              Ada_Put_Line(to_spec,
                "    " &
                Popup_num_to_Ada_ident(menu_popup_counter) &
                ": Menu_Type; "
                & " -- level" & Integer'Image(popup_top+1) &
                "; title: " &
                S(last_popup_title)
              );
              Ada_Put_Line(to_body,
                "    Menu." &
                Popup_num_to_Ada_ident(menu_popup_counter) &
                ":= Create_Popup;"
              );
              Ada_Put_Line(to_body,
                "    Append_Menu(Menu." &
                Popup_num_to_Ada_ident(popup_stack(popup_top)) &
                ", " & S(last_popup_title) &
                ", Menu." &
                Popup_num_to_Ada_ident(menu_popup_counter) &
                ");"
              );
              popup_top:= popup_top+1;
              popup_stack(popup_top):= menu_popup_counter;
            

when 353 => -- #line 1270

              popup_top:= popup_top-1;
            

when 354 => -- #line 1278

              style_switch:= (others => False); -- Reset all style switches
              Ada_Put(to_body,
                "    Append_Item(Menu." &
                Popup_num_to_Ada_ident(popup_stack(popup_top)) &
                ", " & yytext
              );
            

when 355 => -- #line 1288

              Insert_last_symbol;
              Ada_Put_Line(to_body, ", " & S(last_Ada_constant) & ");");
            

when 356 => -- #line 1293

              if style_switch(grayed) then
                Ada_Put_Line(to_body, "    State(Menu." &
                Popup_num_to_Ada_ident(popup_stack(popup_top)) &
                ", Command, " & S(last_Ada_constant) &
                ", Grayed);");
              end if;
              if style_switch(inactive) then
                Ada_Put_Line(to_body, "    State(Menu." &
                Popup_num_to_Ada_ident(popup_stack(popup_top)) &
                ", Command, " & S(last_Ada_constant) &
                ", Disabled);");
              end if;
              if style_switch(checked) then
                Ada_Put_Line(to_body, "    Check(Menu." &
                Popup_num_to_Ada_ident(popup_stack(popup_top)) &
                ", Command, " & S(last_Ada_constant) &
                ", True);");
              end if;
            

when 363 => -- #line 1327
 style_switch(grayed):= True; 

when 364 => -- #line 1328
 style_switch(inactive):= True; 

when 365 => -- #line 1329
 style_switch(checked):= True; 

when 369 => -- #line 1338

              Ada_Put_Line(to_body,
                "    Append_Separator(Menu." &
                Popup_num_to_Ada_ident(popup_stack(popup_top)) &
                ");"
              );
            

when 394 => -- #line 1423

                 Open_if_separate("Version_info", with_body => False);
                 if not separate_items then
                   Ada_Put_Line(to_spec, "  package Version_info is");
                 end if;
               

when 395 => -- #line 1431
 if not separate_items then
                   Ada_Put_Line(to_spec, "  end Version_info;");
                   Ada_New_Line(to_spec);
                 end if;
                 Close_if_separate("Version_info", with_body => False);
               

when 414 => -- #line 1482
RC_Help.version_info_value_counter:= 0;

when 419 => -- #line 1497
RC_Help.version_info_value_counter:= RC_Help.version_info_value_counter + 1;
              case RC_Help.version_info_value_counter is
                when 1 =>
                  declare
                    item: constant String:= yytext;
                  begin
                    Ada_Put(to_spec, "    " & item(item'First+1..item'Last-1));
                  end;
                when 2 =>
                  Ada_Put_Line(to_spec, ": constant String:= " & yytext & ';');
                when others =>
                  null;
              end case;
             

when 420 => -- #line 1512
RC_Help.version_info_value_counter:= RC_Help.version_info_value_counter + 1;
              case RC_Help.version_info_value_counter is
                when 1 =>
                  null; -- should not happen...
                when 2 =>
                  Ada_Put_Line(to_spec, ": constant:=" & Long_Long_Integer'Image(yylval.intval) & ';');
                when others =>
                  null;
              end case;
             

when 434 => -- #line 1582
Treat_include(yytext(2..yylength-1));

when 441 => -- #line 1607
Treat_include(yytext(2..yylength-1));

when 442 => -- #line 1610
Treat_include(yytext(2..yylength-1));

when 457 => -- #line 1662
 last_ident:= U(yytext);
             last_Ada_constant:= Ada_ify(yytext);
             last_Ada_ident:= last_Ada_constant;
             -- normally no confusion here (record entry vs int. constant)
             anonymous_item:= False;
           

when 458 => -- #line 1669
 last_ident:= U(yytext);
             last_Ada_constant:= last_ident;
             if yylval.intval < -1 then
               last_Ada_ident:= U("RC_item_Minus_Invalid" & yytext);
             elsif yylval.intval = -1 then
               New_static_item;
               last_Ada_constant:= U("IDC_STATIC");
             else
               last_Ada_ident:= U("RC_item_" & yytext);
             end if;
             anonymous_item:= True;
           

when 459 => -- #line 1682
 last_ident:= U(yytext);
             last_Ada_constant:= last_ident;
             New_static_item;
             anonymous_item:= True;
           

                    when others => null;
                end case;


            -- Pop RHS states and goto next state
            yy.tos      := yy.tos - rule_length(yy.rule_id) + 1;
            if yy.tos > yy.stack_size then
                text_io.put_line(" Stack size exceeded on state_stack");
                raise yy_Tokens.syntax_error;
            end if;
            yy.state_stack(yy.tos) := goto_state(yy.state_stack(yy.tos-1) ,
                                 get_lhs_rule(yy.rule_id));

              yy.value_stack(yy.tos) := yyval;

            if yy.debug then
                reduce_debug(yy.rule_id,
                    goto_state(yy.state_stack(yy.tos - 1),
                               get_lhs_rule(yy.rule_id)));
            end if;

        end if;


    end loop;


end yyparse;
